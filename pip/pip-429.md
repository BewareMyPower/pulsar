# PIP-429: Client-Side Computation of Last Compacted Message ID

# Background knowledge

The typical reader's work flow looks like:

```java
while (reader.hasMessageAvailable()) {
    final var msg = reader.readNext();
    handleMessage(msg);
}
```

`hasMessageAvailable` could perform the `GetLastMessageId` RPC to get the last message ID from broker. However, when the reader is a compacted reader, i.e. `readCompacted(true)` is configured when creating the reader, the server side could compute the message ID from the last entry in the compaction service.

Generally, with the built-in compaction service, when the entry represents a batch of messages, the compacted entry buffer consists of:

1. Serialized `MessageMetadata`
2. Serialized payload buffer, which can be compressed or encrypted. The uncompressed payload buffer consists of a list of `SingleMessageMetadata` and value buffers.

Take a typical example, when a producer that configures `LZ4` as the compression type sends the following messages in a batch:

```java
producer.newMessage().key("k0").value("v0").sendAsync();
producer.newMessage().key("k0").value("v1").sendAsync();
producer.newMessage().key("k1").value("v0").sendAsync();
producer.newMessage().key("k1").value(null).sendAsync();
```

After the compaction, the compacted entry buffer could be represented as follows:

```yaml
metadata: # MessageMetadata
  num_messages_in_batch: 4
  compression: LZ4
payload:
  - singleMetadata: # SingleMessageMetadata
      key: k0
      compactedOut: true
    value: ""
  - singleMetadata:
      key: k0
      compactedOut: false
    value: v1
  - singleMetadata:
      key: k1
      compactedOut: true
    value: ""
  - singleMetadata:
      key: k1
      compactedOut: true
      nullValue: true
    value: ""
```

- For a given key, only the latest value will be retained, so `k0 => v0` will be compacted out.
- A null value means the key will be removed, so `k1 => v0` and `k1 => null` will be compacted out.

Prior to [#18877](https://github.com/apache/pulsar/pull/18877), the `hasMessageAvailable` and `readNext` loop might encounter issues because the `GetLastMessageId` RPC returns `{ledger, entry, batchIndex=3}` as the last message ID, which represents `k1 => null`.

The issue occurs because the batch index of the last message ID is calculated as `num_messages_in_batch - 1` without considering certain edge cases. [#18877](https://github.com/apache/pulsar/pull/18877) resolves this problem by uncompressing the compacted entry buffer on the broker side and filtering out messages where the individual metadata has `compactedOut` set to `true`. This ensures that only valid messages are considered when determining the last message ID.

# Motivation

Currently, if the last message of a topic is stored in the compacted ledger, each `GetLastMessageId` RPC must uncompress the compacted entry buffer and deserialize both the `MessageMetadata` and `SingleMessageMetadata` to compute the last message ID. This process can become resource-intensive, especially when handling a large number of such topics.

Additionally, if the messages are encrypted, they cannot be uncompressed because the public key is required for decryption. This limitation also affects the current compaction service, as encrypted messages cannot be compacted. As a result, the `GetLastMessageId` RPC will fail with an error similar to the following:

```
org.apache.pulsar.client.api.PulsarClientException$BrokerMetadataException: The subscription sub of the topic <topic> gets the last message id was failed
{"errorMsg":"Failed to read last entry of the compacted Ledger Invalid unknown tag type: 3","reqId":3317275583068061944, "remote":"localhost/127.0.0.1:50818", "local":"/127.0.0.1:50823"}
```

Instead, the expected behavior is to return the last message ID (e.g., `k1 => null` in the previous example).

Another issue arises from the assumption made by the `GetLastMessageId` RPC that the compacted entry's payload buffer must always contain a `SingleMessageMetadata` list. However, this is not always the case. For instance, a custom topic compaction service might write a payload buffer that omits the `SingleMessageMetadata`. In such cases, the `compactedOut` information could instead be stored in the properties of the `MessageMetadata`, but the `GetLastMessageId` RPC will always fail.

# Goals

## In Scope

Shift the logic for computing the last message ID from the broker side to the client side. This change will enable the client to compute the last message ID without requiring the uncompression or decryption of the compacted entry buffer.

## Out of Scope

The topic compaction service's components are complex and not optimally designed. While this PIP will make minimal modifications to the visibility levels of certain methods, such changes will only be made when absolutely necessary. For example, to allow a derived class to customize a `RawReader`.

# High Level Design

The client will have a newer protocol version. When the broker receives a `GetLastMessageId` request and validates the protocol version supports this feature, it will skip decompressing the entry buffer. Instead, it will send the payload buffer after the `GetLastMessageId` response. The client will then handle the payload buffer to compute the last message ID.

To allow a different format of the compacted entry buffer, a configurable function will be used to compute a message id from the payload buffer.

# Detailed Design

## Design & Implementation Details

In the `ServerCnx#handleLastMessageIdFromCompactionService` method, the computation logic will be bypassed if the remote protocol version is v22 or later. This ensures compatibility with newer protocol versions, where the client is expected to handle the relevant processing independently.

```java
persistentTopic.getTopicCompactionService().readLastCompactedEntry().thenAccept(entry -> {
    if (entry != null) {
        if (getRemoteEndpointProtocolVersion() >= v22.getValue()) {
            sendGetLastMessageIdResponseWithBuffer(requestId, partitionIndex, entry, markDeletePosition);
            return;
        }
```

The `sendGetLastMessageIdResponseWithBuffer` method will serialize the `CommandGetLastMessageIdResponse` object and the entry buffer into a `ByteBufPair`.

```java
public static ByteBufPair newGetLastMessageIdResponse(long requestId, long lastPositionLedgerId,
                                                      long lastPositionEntryId, int partitionIndex,
                                                      long markDeleteLedgerId, long markDeleteEntryId,
                                                      ByteBuf lastEntryBuffer) {
```

The consumer or reader will handle the payload processing by first decompressing it based on the compression type specified in the `MessageMetadata`. After decompression, the payload will be decrypted using the configured crypto key reader. This ensures that the payload is properly prepared for further processing, adhering to the specified compression and encryption settings.

## Public-facing Changes

```java
interface LastEntry {

    long getLedgerId();

    long getEntryId();

    int getPartitionIndex();

    /**
     * @return the buffer that can be parsed to the `MessageMetadata` defined in `PulsarApi.proto`
     */
    ByteBuffer getMetadataBuffer();

    /**
     * @return the uncompressed and unencrypted payload buffer of the last entry
     */
    ByteBuffer getPayloadBuffer();
}

interface PayloadToMessageIdConverter {

    MessageId convert(LastEntry lastEntry) throws IOException;
}
```

The `LastEntry` interface offers two distinct methods to retrieve the metadata buffer and the payload buffer of the last entry. This design ensures that the consumer has the flexibility to handle the payload appropriately. Specifically, the consumer is responsible for decompressing and decrypting the payload buffer before passing it to the `PayloadToMessageIdConverter`. It is important to note that if the payload buffer has been compressed or encrypted, the metadata buffer and the payload buffer will differ.

A new configuration option will be introduced for `Consumer`, `Reader`, and `RawReader` to enhance their flexibility and functionality. Additionally, this proposal addresses a previously missing feature (see [PIP-96](https://github.com/apache/pulsar/wiki/PIP-96%3A-Message-payload-processor-for-Pulsar-client)) by adding the `messagePayloadProcessor` configuration to the `Reader`. This enhancement enables the `Reader` to process entry buffers in various formats, ensuring better adaptability to different use cases.

```java
/**
 * Configures a custom `PayloadToMessageIdConverter` to handle the parsing of the last entry's buffer when
 * {@link ConsumerBuilder#readCompacted(boolean)} is set to `true`.
 *
 * When compaction is enabled, the `GetLastMessageId` response may include the buffer of the last entry from the
 * compaction service. In such cases, the last message's message ID must be extracted from the buffer, as the entry
 * may contain messages that have been compacted out and will not be delivered to the consumer.
 *
 * If the broker's topic compaction service uses the built-in implementation, users do not need to configure this
 * explicitly, as the default conversion function handles the parsing correctly. However, if the broker is configured
 * with a custom topic compaction service, you must provide a `converter` with an appropriate function to parse the
 * buffer correctly based on the behavior of the custom compaction service.
 *
 * If the provided `converter` throws an exception during parsing, the corresponding result of
 * {@link Consumer#getLastMessageIdsAsync()} will fail with that exception.
 *
 * @param converter The custom `PayloadToMessageIdConverter` to parse the last entry's buffer.
 * @return The updated `ConsumerBuilder` instance.
 */
ConsumerBuilder<T> payloadToMessageIdConverter(PayloadToMessageIdConverter converter);
```

```java
/**
 * @see ConsumerBuilder#messagePayloadProcessor
 */
ReaderBuilder<T> messagePayloadProcessor(MessagePayloadProcessor payloadProcessor);

/**
 * @see ConsumerBuilder#payloadToMessageIdConverter
 */
ReaderBuilder<T> payloadToMessageIdConverter(ConsumerBuilder.PayloadToMessageIdConverter converter);
```

A new constructor will be added to `RawReaderImpl`:

```java
public RawReaderImpl(PulsarClientImpl client, String topic, String subscription,
                     CompletableFuture<Consumer<byte[]>> consumerFuture,
                     boolean createTopicIfDoesNotExist, boolean retryOnRecoverableErrors,
                     ConsumerBuilder.PayloadToMessageIdConverter payloadToMessageIdConverter) {
```

and the `Compactor` will have a protected method to allow derived classes to customize the `RawReader`:

```java
protected CompletableFuture<RawReader> createRawReader(String topic) {
    return RawReader.create(pulsar, topic, COMPACTION_SUBSCRIPTION, false, false);
}
```

### Binary protocol

Add a new protocol version:

```protobuf
    v22 = 22; // Send the last entry's payload buffer to the consumer if the consumer's read_compacted field is true
```

Older clients will continue to rely on the broker's logic to compute the last message ID, while newer clients will handle this computation on the client side.

# Backward & Forward Compatibility

- **Scenario 1: Older Client → Newer Broker**
  When an older client sends a `GetLastMessageId` request to a newer broker, the broker computes the last message ID using its standard process. To ensure backward compatibility, the broker excludes the payload buffer from the response, aligning with the expectations of older clients.

- **Scenario 2: Newer Client → Older Broker**
  When a newer client sends a `GetLastMessageId` request to an older broker, the broker does not include the payload buffer in the response, as it lacks support for this feature. If the client receives an empty entry buffer, it seamlessly extracts the message ID directly from the response, ensuring compatibility and uninterrupted functionality across versions.

# Alternatives

[#24431](https://github.com/apache/pulsar/pull/24431) proposed a solution to add a property to the `MessageMetadata` to indicate the last available message's batch index in the batch. However, it's not flexiable and might have conflicts with user provided properties.

# Links

* Mailing List discussion thread: https://lists.apache.org/thread/4jghjg7yd36cl8yonbsvk5njmm96vy0k
* Mailing List voting thread:
